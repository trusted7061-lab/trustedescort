const express = require('express');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const mongoose = require('mongoose');
const { body, validationResult } = require('express-validator');
const User = require('../models/User');
const sendEmail = require('../services/emailService');
const otpGenerator = require('otp-generator');

const router = express.Router();

// Register
router.post('/register', [
  body('email').isEmail().normalizeEmail(),
  body('password').isLength({ min: 6 })
], async (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  const { email, password, businessName, phone, location, services, description, averageRate, availability, photos, userType } = req.body;

  try {
    // Check if database is connected
    if (mongoose.connection.readyState !== 1) {
      console.log('Database not connected, using localStorage fallback for registration');
      
      // For development, simulate successful registration
      const otp = otpGenerator.generate(6, { upperCaseAlphabets: false, specialChars: false });
      
      console.log(`=== REGISTRATION SIMU  LATION ===`);
      console.log(`Email: ${email}`);
      console.log(`Business: ${businessName}`);
      console.log(`OTP: ${otp}`);
      console.log(`===============================`);
      
      return res.status(201).json({
        message: 'User registered, please verify email',
        emailSent: false, // Email not sent due to no database
        otp: otp // Include OTP for testing (remove in production)
      });
    }

    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({ message: 'User already exists' });
    }

    const passwordHash = await bcrypt.hash(password, 12);
    const otp = otpGenerator.generate(6, { upperCaseAlphabets: false, specialChars: false });
    const otpExpires = new Date(Date.now() + 10 * 60 * 1000); // 10 minutes

    const user = new User({
      email,
      passwordHash,
      otp,
      otpExpires,
      businessName,
      phone,
      location,
      services,
      description,
      averageRate,
      availability,
      photos,
      userType: userType || 'user'
    });
    await user.save();

    // Send verification email (will log to console if SendGrid not configured)
    let emailSent = true;
    try {
      await sendEmail(email, 'Verify your email', `Your OTP is ${otp}`);
    } catch (emailError) {
      console.error('Email sending failed:', emailError);
      emailSent = false;
    }

    res.status(201).json({
      message: 'User registered, please verify email',
      emailSent: emailSent
    });
  } catch (err) {
    console.error('Registration error:', err);
    res.status(500).json({ message: 'Server error' });
  }
});

// Verify email (alias for verify-otp for frontend compatibility)
router.post('/verify-email', [
  body('email').isEmail().normalizeEmail(),
  body('code').isLength({ min: 6, max: 6 })
], async (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  const { email, code } = req.body;

  try {
    const user = await User.findOne({ email });
    if (!user || user.otp !== code || user.otpExpires < new Date()) {
      return res.status(400).json({ message: 'Invalid or expired verification code' });
    }

    user.isVerified = true;
    user.otp = undefined;
    user.otpExpires = undefined;
    await user.save();

    const accessToken = jwt.sign({ userId: user._id }, process.env.JWT_SECRET, { expiresIn: '15m' });

    res.json({
      token: accessToken,
      user: {
        id: user._id,
        email: user.email,
        businessName: user.businessName,
        phone: user.phone,
        userType: user.userType
      }
    });
  } catch (err) {
    res.status(500).json({ message: 'Server error' });
  }
});

// Login
router.post('/login', [
  body('email').isEmail().normalizeEmail(),
  body('password').exists()
], async (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  const { email, password } = req.body;

  try {
    const user = await User.findOne({ email });
    if (!user || !await bcrypt.compare(password, user.passwordHash)) {
      return res.status(400).json({ message: 'Invalid credentials' });
    }

    if (!user.isVerified) {
      return res.status(400).json({
        requiresVerification: true,
        user: {
          id: user._id,
          email: user.email,
          businessName: user.businessName,
          phone: user.phone,
          userType: user.userType
        },
        emailSent: true
      });
    }

    const accessToken = jwt.sign({ userId: user._id }, process.env.JWT_SECRET, { expiresIn: '15m' });
    const refreshToken = jwt.sign({ userId: user._id }, process.env.JWT_REFRESH_SECRET, { expiresIn: '7d' });

    user.refreshToken = refreshToken;
    await user.save();

    // Return token and user data for frontend compatibility
    res.json({
      token: accessToken,
      user: {
        id: user._id,
        email: user.email,
        businessName: user.businessName,
        phone: user.phone,
        userType: user.userType
      }
    });
  } catch (err) {
    res.status(500).json({ message: 'Server error' });
  }
});

// Forgot Password
router.post('/forgot-password', [
  body('email').isEmail().normalizeEmail()
], async (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  const { email } = req.body;

  try {
    const user = await User.findOne({ email });
    if (!user) {
      return res.status(400).json({ message: 'User not found' });
    }

    const otp = otpGenerator.generate(6, { upperCaseAlphabets: false, specialChars: false });
    user.otp = otp;
    user.otpExpires = new Date(Date.now() + 10 * 60 * 1000);
    await user.save();

    await sendEmail(email, 'Reset your password', `Your reset OTP is ${otp}`);

    res.json({ message: 'Reset OTP sent' });
  } catch (err) {
    res.status(500).json({ message: 'Server error' });
  }
});

// Resend verification code
router.post('/resend-verification', [
  body('email').isEmail().normalizeEmail()
], async (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  const { email } = req.body;

  try {
    const user = await User.findOne({ email });
    if (!user) {
      return res.status(400).json({ message: 'User not found' });
    }

    if (user.isVerified) {
      return res.status(400).json({ message: 'User is already verified' });
    }

    const otp = otpGenerator.generate(6, { upperCaseAlphabets: false, specialChars: false });
    user.otp = otp;
    user.otpExpires = new Date(Date.now() + 10 * 60 * 1000); // 10 minutes
    await user.save();

    // Send verification email
    let emailSent = true;
    try {
      await sendEmail(email, 'Verify your email', `Your verification OTP is ${otp}`);
    } catch (emailError) {
      console.error('Email sending failed:', emailError);
      emailSent = false;
    }

    res.json({
      message: 'Verification code sent',
      emailSent: emailSent
    });
  } catch (err) {
    res.status(500).json({ message: 'Server error' });
  }
});

// Resend verification code
router.post('/resend-verification', [
  body('email').isEmail().normalizeEmail()
], async (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  const { email } = req.body;

  try {
    const user = await User.findOne({ email });
    if (!user) {
      return res.status(400).json({ message: 'User not found' });
    }

    if (user.isVerified) {
      return res.status(400).json({ message: 'User is already verified' });
    }

    const otp = otpGenerator.generate(6, { upperCaseAlphabets: false, specialChars: false });
    user.otp = otp;
    user.otpExpires = new Date(Date.now() + 10 * 60 * 1000); // 10 minutes
    await user.save();

    // Send verification email
    let emailSent = true;
    try {
      await sendEmail(email, 'Verify your email', `Your verification OTP is ${otp}`);
    } catch (emailError) {
      console.error('Email sending failed:', emailError);
      emailSent = false;
    }

    res.json({
      message: 'Verification code sent',
      emailSent: emailSent
    });
  } catch (err) {
    res.status(500).json({ message: 'Server error' });
  }
});

module.exports = router;
